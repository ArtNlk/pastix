extern "C" %{
  /**
   * PLASMA include for defined and constants.
   *
   * @precisions normal z -> s d c
   *
   */
#include <dague.h>
#include <dague/data_distribution.h>
#include <dague/private_mempool.h>
#include "common.h"
#include "pastix_zcores.h"
#include "sopalin_data.h"
#include "parsec/sparse-matrix.h"

/* #if defined(HAVE_CUDA) */
/* #include <dague/devices/cuda/dev_cuda.h> */
/* #include "parsec/cuda_zgemmsp.h" */
/* #endif  /\* defined(HAVE_CUDA) *\/ */
%}

/* Globals
 */
dataA        [type = "dague_ddesc_t *" ]
sopalin_data [type = "sopalin_data_t *" ]

descA    [type = "sparse_matrix_desc_t*" hidden = on default = "((sparse_matrix_desc_t*)dataA)"]
datacode [type = "SolverMatrix*"         hidden = on default = "(sopalin_data->solvmtx)"       ]
cblknbr  [type = "pastix_int_t"          hidden = on default = "(datacode->cblknbr - 1)"       ]
bloknbr  [type = "pastix_int_t"          hidden = on default = "(datacode->bloknbr - 2)"       ]

p_work   [type = "dague_memory_pool_t *" size = "datacode->gemmmax * sizeof(pastix_complex64_t)"]

/**************************************************
 *                GETRF_TRSM                      *
 * panel factorization: do trf of diagonal and    *
 *                    : trsm on off-diagonal      *
 **************************************************/
GETRF_TRSM(k) [high_priority = on]

// Execution space
k = 0 .. cblknbr

browk0    = inline_c %{ SolverCblk *cblk = datacode->cblktab + k;     return cblk->brownum; %}
browk1    = inline_c %{ SolverCblk *cblk = datacode->cblktab + k + 1; return cblk->brownum; %}
firstblok = inline_c %{ SolverCblk *cblk = datacode->cblktab + k;     return cblk->fblokptr - datacode->bloktab + 1; %}
lastblok  = inline_c %{ SolverCblk *cblk = datacode->cblktab + k + 1; return cblk->fblokptr - datacode->bloktab - 1; %}
lastbrow  = inline_c %{ if ( browk0 == browk1 ) return 0; else return datacode->browtab[ browk1 - 1 ]; %}

// Parallel partitioning
:dataA(0, k) // Should match SOLV_COEFTAB(k)

// Parameters
/* C is A(k) if it's a leaf or get the cblk from the last update */
RW L <- ( browk0 == browk1 ) ? dataA(0, k) : Cl GEMM( lastbrow )
     -> Al GEMM(firstblok .. lastblok)
     -> dataA(0, k)

RW U <- ( browk0 == browk1 ) ? dataA(1, k) : Cu GEMM( lastbrow )
     -> Au GEMM(firstblok .. lastblok)
     -> dataA(1, k)

     //; inline_c %{ return - TASK_PRIONUM(k); %}
BODY
{
    SolverCblk *cblk = datacode->cblktab + k;

    core_zgetrfsp1d_panel( cblk, L, U, sopalin_data->diagthreshold );

#if defined(PASTIX_DEBUG_FACTO)
    //coeftab_zdump( datacode, "getrf_L.txt" );
#endif
}
END

/**************************************************
 *                      GEMM                      *
 * update the trailing matrix with the panel      *
 * k-th block updating corresponding.
 **************************************************/

GEMM(bloknum)

// Execution space
bloknum = 1 .. bloknbr

lcblknm = inline_c %{ SolverBlok *blok = datacode->bloktab + bloknum;     return blok->lcblknm; %}
fcblknm = inline_c %{ SolverBlok *blok = datacode->bloktab + bloknum;     return blok->fcblknm; %}
first   = inline_c %{ SolverCblk *cblk = datacode->cblktab + fcblknm;     return cblk->brownum; %}
last    = inline_c %{ SolverCblk *cblk = datacode->cblktab + fcblknm + 1; return cblk->brownum - 1; %}

brownum = inline_c %{ return datacode->bloktab[bloknum].browind; %}
prev    = inline_c %{ if ((brownum == -1) || (brownum <= first)) return 0; else return datacode->browtab[brownum-1]; %}
next    = inline_c %{ if ((brownum == -1) || (brownum >= last )) return 0; else return datacode->browtab[brownum+1]; %}

// Parallel partitioning
:dataA(0, fcblknm)

// Parameters
READ  Al <- ( brownum != -1) ? L GETRF_TRSM( lcblknm ) : dataA( 0, fcblknm )
READ  Au <- ( brownum != -1) ? U GETRF_TRSM( lcblknm ) : dataA( 1, fcblknm )

RW    Cl <- ( brownum == -1 ) || (first == brownum ) ? dataA( 0, fcblknm )
         <- ( brownum != -1 ) && (first != brownum ) ? Cl GEMM( prev )

         -> ( brownum != -1 ) && (last == brownum ) ? L GETRF_TRSM( fcblknm )
         -> ( brownum != -1 ) && (last != brownum ) ? Cl GEMM( next )

RW    Cu <- ( brownum == -1 ) || (first == brownum ) ? dataA( 1, fcblknm )
         <- ( brownum != -1 ) && (first != brownum ) ? Cu GEMM( prev )

         -> ( brownum != -1 ) && (last == brownum ) ? U GETRF_TRSM( fcblknm )
         -> ( brownum != -1 ) && (last != brownum ) ? Cu GEMM( next )

//; inline_c %{ return - TASK_PRIONUM(fcblk); %}

/* BODY [type=CUDA] */
/* { */
/*     int rc = 0; */
/*     /\* If diagonal block, we skip *\/ */
/*     if (brownum == -1) { */
/*         goto end; */
/*     } */

/*     SolverCblk *lcblk = datacode->cblktab + lcblknm; */
/*     SolverCblk *fcblk = datacode->cblktab + fcblknm; */
/*     SolverBlok *blok  = datacode->bloktab + bloknum; */
/*     pastix_complex64_t *work; */

/*     rc = gpu_zgetrfsp_gemm( context, this_task, (last == brownum ), */
/*                             lcblk, blok, fcblk, Al, Au, Cl, Cu ); */

/*   end: */
/*     return rc; */
/* } */
/* END */

BODY
{
    /* If diagonal block, we skip */
    if (brownum == -1) {
        goto end;
    }

    SolverCblk *lcblk = datacode->cblktab + lcblknm;
    SolverCblk *fcblk = datacode->cblktab + fcblknm;
    SolverBlok *blok  = datacode->bloktab + bloknum;
    pastix_complex64_t *work;

    work = (pastix_complex64_t *)dague_private_memory_pop( p_work );

    /* Update on L */
    core_zgemmsp( PastixLower, PastixTrans, lcblk, blok, fcblk,
                  Al, Au, Cl, work );

    /* Update on U */
    if ( blok+1 < lcblk[1].fblokptr ) {
        core_zgemmsp( PastixUpper, PastixTrans, lcblk, blok, fcblk,
                      Au, Al, Cu, work );
    }

    dague_private_memory_push( p_work, (void *)work );
  end:
    ;
}
END
