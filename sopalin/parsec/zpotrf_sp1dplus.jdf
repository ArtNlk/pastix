extern "C" %{
  /**
   * PLASMA include for defined and constants.
   *
   * @precisions normal z -> s d c
   *
   */
#include <dague.h>
#include <dague/data_distribution.h>
#include <dague/private_mempool.h>
#include "common.h"
#include "pastix_zcores.h"
#include "sopalin_data.h"
#include "parsec/sparse-matrix.h"

#if defined(DAGUE_HAVE_CUDA)
#include <cuComplex.h>

typedef struct gemm_params_s{
    int M[32];
    int Acoefind[32];
    void *Carray[32];
} gemm_params_t;

/* typedef void (*pastix_zgemm_vbatched_nt_t) */
/*     (pastix_trans_t transB, */
/*      pastix_int_t m[32], pastix_int_t n, pastix_int_t k, */
/*      cuDoubleComplex alpha, */
/*      cuDoubleComplex const * dA, pastix_int_t ldda, */
/*      cuDoubleComplex const * dB, pastix_int_t lddb, */
/*      cuDoubleComplex beta, */
/*      cuDoubleComplex       * dC_array[32], pastix_int_t lddc, */
/*      pastix_int_t max_m, pastix_int_t batchCount, */
/*      const pastix_int_t Acoefind[32], cudaStream_t stream ); */

typedef void (*pastix_zgemm_vbatched_nt_t)
    (gemm_params_t params,
     pastix_trans_t transB,
     pastix_int_t n, pastix_int_t k,
     cuDoubleComplex alpha,
     cuDoubleComplex const * dA, pastix_int_t ldda,
     cuDoubleComplex const * dB, pastix_int_t lddb,
     cuDoubleComplex beta,
     pastix_int_t lddc,
     pastix_int_t max_m, pastix_int_t batchCount,
     cudaStream_t stream );

#endif  /* defined(HAVE_CUDA) */
%}

/* Globals
 */
dataA        [type = "dague_ddesc_t *" ]
sopalin_data [type = "sopalin_data_t *" ]

descA    [type = "sparse_matrix_desc_t*" hidden = on default = "((sparse_matrix_desc_t*)dataA)"]
datacode [type = "SolverMatrix*"         hidden = on default = "(sopalin_data->solvmtx)"       ]
cblknbr  [type = "pastix_int_t"          hidden = on default = "(datacode->cblknbr - 1)"       ]
bloknbr  [type = "pastix_int_t"          hidden = on default = "(datacode->bloknbr - 1)"       ]

p_work   [type = "dague_memory_pool_t *" size = "datacode->gemmmax * sizeof(pastix_complex64_t)"]

/**************************************************
 *                POTRF_TRSM                      *
 * panel factorization: do trf of diagonal and    *
 *                    : trsm on off-diagonal      *
 **************************************************/
POTRF_TRSM(k) [high_priority = on]

// Execution space
k = 0 .. cblknbr

browk0    = inline_c %{ SolverCblk *cblk = datacode->cblktab + k;     return cblk->brownum; %}
browk1    = inline_c %{ SolverCblk *cblk = datacode->cblktab + k + 1; return cblk->brownum; %}
firstblok = inline_c %{ SolverCblk *cblk = datacode->cblktab + k;     return cblk->fblokptr - datacode->bloktab + 1; %}
lastblok  = inline_c %{ SolverCblk *cblk = datacode->cblktab + k + 1; return cblk->fblokptr - datacode->bloktab - 1; %}
lastbrow  = inline_c %{ if ( browk0 == browk1 ) return 0; else return datacode->browtab[ browk1 - 1 ]; %}

// Parallel partitioning
:dataA(0, k) // Should match SOLV_COEFTAB(k)

// Parameters
/* C is A(k) if it's a leaf or get the cblk from the last update */
RW L <- ( browk0 == browk1 ) ? C GEMM( firstblok-1 ) : C GEMM( lastbrow )
     -> A GEMM(firstblok .. lastblok)
     -> dataA(0, k)

//; inline_c %{ return - TASK_PRIONUM(k); %}
BODY
{
    SolverCblk *cblk = datacode->cblktab + k;

    core_zpotrfsp1d_panel( cblk, L, sopalin_data->diagthreshold );

#if defined(HAVE_CUDA) && 0
    {
        pastix_int_t *lMs = (pastix_int_t*)Ms;
        pastix_int_t *lAs = (pastix_int_t*)As;

        SolverBlok *blok  = cblk[0].fblokptr + 1;
        SolverBlok *lblok = cblk[1].fblokptr;
        int i;

        for (i=0; blok<lblok; blok++, i++) {
            lMs[i] = blok->lrownum - blok->frownum + 1;
            lAs[i] = blok->coefind;
        }
    }
#endif /* defined(HAVE_CUDA) */

}
END

/**
 *       GEMM
 *
 * To have a contiguous range of GEMM to release in the potrf, they are numbered
 * with the indexes of the off-diagonal blocks, diagonal block included.
 * Thus, the diagonal block tasks which doesn't perfom computations are used as
 * DATA_IN tasks. This is mandatory when using the GPU, due to the versioning
 * bumped by the cpu version of the diagonal block that coccurs when computing
 * the diagonal blocks.
 *
 * For all off-diagonal blocks, it updates the trailing matrix with the panel
 * k-th block updating corresponding.
 *
 */
GEMM(bloknum)

// Execution space
bloknum = 0 .. bloknbr

lcblknm = inline_c %{ SolverBlok *blok = datacode->bloktab + bloknum;     return blok->lcblknm; %}
fcblknm = inline_c %{ SolverBlok *blok = datacode->bloktab + bloknum;     return blok->fcblknm; %}
first   = inline_c %{ SolverCblk *cblk = datacode->cblktab + fcblknm;     return cblk->brownum; %}
last    = inline_c %{ SolverCblk *cblk = datacode->cblktab + fcblknm + 1; return cblk->brownum - 1; %}

brownum = inline_c %{ return datacode->bloktab[bloknum].browind; %} /* -1 if diagonal block */
prev    = inline_c %{
    assert( first >= 0 );
    /* If bloknum is a diagonal block, they are no previous */
    if (brownum == -1) {
        return 0;
    }
    /* Now, if we are doing the first gemm on fcblk, then we got the C from the diagonal block */
    else if (brownum == first) {
        return datacode->cblktab[fcblknm].fblokptr - datacode->bloktab;
    } else {
        assert( brownum > first );
        /* Otherwise we return the previous block in the list of blocks facing fcblk */
        return datacode->browtab[brownum-1];
    }
    %}
next    = inline_c %{
    /* If we are on a diagonal blok */
    if (brownum == -1) {
        /* If this is not a leaf */
        if (last >= first) {
            return datacode->browtab[first];
        } else {
            return 0;
        }
    } else {
        /* if we are the last one, we return 0 to avoid overflow */
        if (brownum >= last) {
            return 0;
        } else {
            return datacode->browtab[brownum+1];
        }
    }
    %}

// Parallel partitioning
:dataA(0, fcblknm)

// Parameters
READ  A  <- ( brownum != -1) ? L POTRF_TRSM( lcblknm ) : dataA( 0, fcblknm )

RW    C  <- ( brownum == -1 ) ? dataA( 0, fcblknm )
         <- ( brownum != -1 ) ? C GEMM( prev )

         -> ( brownum != -1 ) && ( last == brownum ) ? L POTRF_TRSM( fcblknm )
         -> ( brownum != -1 ) && ( last != brownum ) ? C GEMM( next )
         -> ( brownum == -1 ) && ( last >= first   ) ? C GEMM( next )
         -> ( brownum == -1 ) && ( last <  first   ) ? L POTRF_TRSM( fcblknm )

//; inline_c %{ return - TASK_PRIONUM(fcblk); %}

BODY [type=CUDA
      device=inline_c %{ if (brownum == -1) return -2; else { SolverCblk *cblk = datacode->cblktab + fcblknm; return cblk->gpuid; } %} ]
      /* dyld=pastix_zgemm_vbatched_nt */
      /* dyldtype=pastix_zgemm_vbatched_nt_t ] */
{
#if defined(DAGUE_HAVE_CUDA) && defined(PASTIX_WITH_CUDA)
    /* Compute only if non diagonal block */
    if (brownum != -1) {
#if defined(PRECISION_z) || defined(PRECISION_c)
        cuDoubleComplex zone  = make_cuDoubleComplex( 1., 0.);
        cuDoubleComplex mzone = make_cuDoubleComplex(-1., 0.);
#else
        double zone  =  1.;
        double mzone = -1.;
#endif

        /* pastix_int_t     Ms[32]; /\* = (pastix_int_t*)Ms; *\/ */
        /* pastix_int_t     As[32]; /\* = (pastix_int_t*)As; *\/ */
        /* cuDoubleComplex *Cs[32]; */
        gemm_params_t params;
        cuDoubleComplex *lA = (cuDoubleComplex*)A;
        cuDoubleComplex *lC = (cuDoubleComplex*)C;
        SolverCblk *lcblk = datacode->cblktab + lcblknm;
        SolverCblk *fcblk = datacode->cblktab + fcblknm;
        SolverBlok *blok  = datacode->bloktab + bloknum;
        SolverBlok *iterblok, *fblok, *lblok;

        int count = lcblk[1].fblokptr - blok;
        /* int index = blok - lcblk[0].fblokptr - 1; */
        int max_m = 0;
        int N = blok->lrownum  - blok->frownum  + 1;
        int K = lcblk->lcolnum - lcblk->fcolnum + 1;
        int i;
        /* lMs += index; */
        /* lAs += index; */

        fprintf(stderr, "BacthCount: %d\n", count );

        fblok = fcblk->fblokptr;
        lblok = lcblk[1].fblokptr;

        /* Move the pointer to the top of the right column */
        lC = lC + (blok->frownum - fcblk->fcolnum) * fcblk->stride;

        for (iterblok=blok, i=0; iterblok<lblok; iterblok++, i++) {
            /* Find facing blok */
            while (!is_block_inside_fblock( iterblok, fblok ))
            {
                fblok++;
                assert( fblok < fcblk[1].fblokptr );
            }

            params.M[i]        = iterblok->lrownum - iterblok->frownum + 1;
            params.Acoefind[i] = iterblok->coefind;
            params.Carray[i]   = lC + fblok->coefind + iterblok->frownum - fblok->frownum;

            max_m = pastix_imax( max_m, params.M[i] );

            if (i == 31) {
                //dague_body.dyld_fn(
                pastix_zgemm_vbatched_nt(
                    params,
                    PastixConjTrans, /*Ms,*/ N, K,
                    /* alpha  */  mzone,
                    /* A      */  lA,                 lcblk->stride,
                    /* B      */  lA + blok->coefind, lcblk->stride,
                    /* beta   */  zone,
                    /* C      */ /* Cs,       */          fcblk->stride,
                    max_m, 32, /*As,*/
                    gpu_stream->cuda_stream );
                i = -1;
                count -= 32;
                /* lMs += 32; */
                /* lAs += 32; */
                max_m = 0;
            }
        }

        if (count > 0) {
            //dague_body.dyld_fn(
            pastix_zgemm_vbatched_nt(
                params,
                PastixConjTrans, /*Ms, */N, K,
                /* alpha  */  mzone,
                /* A      */  lA,                 lcblk->stride,
                /* B      */  lA + blok->coefind, lcblk->stride,
                /* beta   */  zone,
                /* C      */  /*Cs,*/                 fcblk->stride,
                max_m, count, /*As,*/
                gpu_stream->cuda_stream );
        }
    }
#endif /* defined(DAGUE_HAVE_CUDA) && defined(PASTIX_WITH_CUDA) */
}
END

BODY
{
    /* If diagonal block, we skip */
    if (brownum == -1) {
        goto end;
    }

    SolverCblk *lcblk = datacode->cblktab + lcblknm;
    SolverCblk *fcblk = datacode->cblktab + fcblknm;
    SolverBlok *blok  = datacode->bloktab + bloknum;
    pastix_complex64_t *work;

    work = (pastix_complex64_t *)dague_private_memory_pop( p_work );

    core_zgemmsp( PastixLower, PastixConjTrans, lcblk, blok, fcblk,
                  A, A, C, work );

    dague_private_memory_push( p_work, (void *)work );
  end:
    ;
}
END
