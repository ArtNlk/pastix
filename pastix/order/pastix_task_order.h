/**
 *
 * @file pastix_task_order.c
 *
 *  PaStiX order routines
 *  PaStiX is a software package provided by Inria Bordeaux - Sud-Ouest,
 *  LaBRI, University of Bordeaux 1 and IPB.
 *
 * Contains the main routine to compute ordering of a given graph.
 *
 * @version 5.1.0
 * @author Xavier Lacoste
 * @author Pierre Ramet
 * @author Mathieu Faverge
 * @date 2013-06-24
 *
 **/

#ifndef PASTIX_TASK_ORDER_H
#define PASTIX_TASK_ORDER_H



/**
 *******************************************************************************
 *
 * @ingroup pastix_ordering
 * @ingroup pastix
 *
 * pastix_task_order - Computes the ordering of the given graph in parameters.
 *
 * The graph given by the user is used to generate a graph that can be used by
 * ordering tools and symbol factorization. This graph is stored in the
 * pastix_data->csc to be pass over to the symbolic factorization. If it exists
 * before to call this routine, then the current structure is cleaned and a new
 * one is created. From this structure, an ordering is computed by the ordering
 * tool chosen by IPARM_ORDERING and stored in pastix_data->ordemesh. If Scotch
 * library is used, the ordering generated also conatins the supernode partition
 * computed directly by Scotch, otherwise this partition is NULL.
 * The user can get back the permutation generated by providing allocated perm
 * and/or invp arrays where the results is stored after computation.
 *
 * This routine is affected by the following parameters:
 *   IPARM_VERBOSE, IPARM_ORDERING, IPARM_SCHUR, IPARM_ISOLATE_ZEROS,
 *   IPARM_IO_STRATEGY
 *
 *******************************************************************************
 *
 * @param[in,out] pastix_data
 *          The pastix_data structure that describes the solver instance.
 *          On exit, the field ordemesh is initialize with the result of the
 *          ordering.
 *          - IPARM_ORDERING will determine which ordering tool is used.
 *          - IPARM_SCHUR enables the extraction of the schur complement from the
 *          user's graph to isolate it at the end of the matrix. The list of
 *          vertices to isolated must be provided through the
 *          pastix_setSchurUnknownList() function.
 *          - IPARM_ISOLATE_ZEROS enables the extraction of the diagonal elements
 *          from the user's graph to isolate it at the end of the matrix. The
 *          list of vertices to isolated must be provided through the
 *          pastix_setZerosUnknownList() function.
 *          - IPARM_IO_STRATEGY will enable the results to be written on files
 *          if set to API_IO_SAVE, or the results to be directly loaded from
 *          file if set to AP√è_IO_LOAD without going through an ordering
 *          library.
 *
 * @param[in] n
 *          The number of vertices.
 *
 * @param[in] colptr
 *          Array of size n+1
 *          The array of indirection to the rows array for each vertex.
 *          rows[ colptr[i] ] to rows[ colptr[i+1] are the edges of the
 *          ith vertex.
 *
 * @param[in] rows
 *          Array of size nnz = colptr[n] - colptr[0]. The array of edges.
 *          rows[ colptr[i]   - colptr[0] ] to
 *          rows[ colptr[i+1] - colptr[0] ] are the edges of the ith vertex.
 *
 * @param[in] loc2glob
 *          Array of size n
 *          Global numbering of each local vertex.
 *          Can be equal to NULL if graph load is asked.
 *
 * @param[in,out] perm
 *          Array of size n.
 *          On entry, the permutation array if IPARM_ORDERING parameter set to
 *          API_ORDER_PERSONAL. Not read otherwise.
 *          On exit, if perm != NULL and IPARM_ORDERING parameter is not set to
 *          API_ORDER_PERSONAL, contains the permutation array
 *          generated. Otherwise, it is not referenced.
 *
 * @param[in,out] invp
 *          Array of size n.
 *          On entry, the inverse permutation array if IPARM_ORDERING parameter
 *          set to API_ORDER_PERSONAL. Not read otherwise.
 *          On exit, if invp != NULL and IPARM_ORDERING parameter is not set to
 *          API_ORDER_PERSONAL, contains the inverse permutation array
 *          generated. Otherwise, it is not referenced.
 *
 *******************************************************************************
 *
 * @return
 *          \retval PASTIX_SUCCESS on successful exit
 *          \retval PASTIX_ERR_BADPARAMETER if one parameter is incorrect.
 *          \retval PASTIX_ERR_OUTOFMEMORY if one allocation failed.
 *          \retval PASTIX_ERR_INTEGER_TYPE if Scotch integer type is not the
 *                  same size as PaStiX ones.
 *          \retval PASTIX_ERR_INTERNAL if an error occurs internally to Scotch.
 *
 *******************************************************************************/
int
pastix_task_order(      d_pastix_data_t *pastix_data,
                        pastix_int_t   n,
                  const pastix_int_t  *colptr,
                  const pastix_int_t  *rows,
                        pastix_int_t  *loc2glob,
                        pastix_int_t  *perm,
                        pastix_int_t  *invp);
#endif /* PASTIX_TASK_ORDER_H */
