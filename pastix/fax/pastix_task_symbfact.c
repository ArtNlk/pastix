/**
 *
 * @file pastix_task_symbfact.c
 *
 *  PaStiX symbolic factorizations routines
 *  PaStiX is a software package provided by Inria Bordeaux - Sud-Ouest,
 *  LaBRI, University of Bordeaux 1 and IPB.
 *
 * Contains wrappers to the symbolic factorization step.
 * Affetcted by the compilation time options:
 *    - PASTIX_SYMBOL_FORCELOAD: Force to load the symbol matrix from file
 *    - PASTIX_SYMBOL_DUMP_SYMBMTX: Dump the symbol matrix in a postscript file.
 *    - COMPACT_SMX: Optimization for solve step (TODO: check if not obsolete)
 *    - FORGET_PARTITION: Force to forget the precomputed partition
 *
 * @version 5.1.0
 * @author Xavier Lacoste
 * @author Pierre Ramet
 * @author Mathieu Faverge
 * @date 2013-06-24
 *
 **/
#include "common.h"
#include "order.h"
#include "fax.h"
#include "kass.h"
#include "csc_utils.h"
#include "cscd_utils_intern.h"


/**
 *******************************************************************************
 *
 * @ingroup pastix_symbfact
 * @ingroup pastix
 *
 * pastix_task_symbfact - Computes the the symbolic factorization of the matrix
 * and if required the amalgamated supernode partition.
 *
 * The graph given by the user is used to generate a graph that can be used by
 * ordering tools and symbol factorization. This graph is stored in the
 * pastix_data->csc to be pass over to the symbolic factorization. If it exists
 * before to call this routine, then the current structure is cleaned and a new
 * one is created. From this structure, an ordering is computed by the ordering
 * tool chosen by IPARM_ORDERING and stored in pastix_data->ordemesh. If Scotch
 * library is used, the ordering generated also conatins the supernode partition
 * computed directly by Scotch, otherwise this partition is NULL.
 * The user can get back the permutation generated by providing allocated perm
 * and/or invp arrays where the results is stored after computation.
 *
 * This routine is affected by the following parameters:
 *   IPARM_VERBOSE, IPARM_ORDERING, IPARM_SCHUR, IPARM_ISOLATE_ZEROS,
 *   IPARM_IO_STRATEGY
 *
 *******************************************************************************
 *
 * @param[in,out] pastix_data
 *          The pastix_data structure that describes the solver instance.
 *          On exit, the field ordemesh is initialize with the result of the
 *          ordering.
 *          - IPARM_ORDERING will determine which ordering tool is used.
 *          - IPARM_SCHUR enables the extraction of the schur complement from the
 *          user's graph to isolate it at the end of the matrix. The list of
 *          vertices to isolated must be provided through the
 *          pastix_setSchurUnknownList() function.
 *          - IPARM_ISOLATE_ZEROS enables the extraction of the diagonal elements
 *          from the user's graph to isolate it at the end of the matrix. The
 *          list of vertices to isolated must be provided through the
 *          pastix_setZerosUnknownList() function.
 *          - IPARM_IO_STRATEGY will enable the results to be written on files
 *          if set to API_IO_SAVE, or the results to be directly loaded from
 *          file if set to APÏ_IO_LOAD without going through an ordering
 *          library.
 *
 * @param[in,out] perm
 *          Array of size n.
 *          On entry, the permutation array if IPARM_ORDERING parameter set to
 *          API_ORDER_PERSONAL. Not read otherwise.
 *          On exit, if perm != NULL and IPARM_ORDERING parameter is not set to
 *          API_ORDER_PERSONAL, contains the permutation array
 *          generated. Otherwise, it is not referenced.
 *
 * @param[in,out] invp
 *          Array of size n.
 *          On entry, the inverse permutation array if IPARM_ORDERING parameter
 *          set to API_ORDER_PERSONAL. Not read otherwise.
 *          On exit, if invp != NULL and IPARM_ORDERING parameter is not set to
 *          API_ORDER_PERSONAL, contains the inverse permutation array
 *          generated. Otherwise, it is not referenced.
 *
 *******************************************************************************
 *
 * @return
 *          \retval PASTIX_SUCCESS on successful exit
 *          \retval PASTIX_ERR_BADPARAMETER if one parameter is incorrect.
 *          \retval PASTIX_ERR_OUTOFMEMORY if one allocation failed.
 *          \retval PASTIX_ERR_INTEGER_TYPE if Scotch integer type is not the
 *                  same size as PaStiX ones.
 *          \retval PASTIX_ERR_INTERNAL if an error occurs internally to Scotch.
 *
 *******************************************************************************/
int
pastix_task_symbfact(pastix_data_t *pastix_data,
                     pastix_int_t  *perm,
                     pastix_int_t  *invp )
{
    pastix_int_t   *iparm;
    pastix_graph_t *graph;
    Order          *ordemesh;
    pastix_int_t    n;
    int             procnum;

#ifdef PASTIX_DISTRIBUTED
    PASTIX_INT           * PTS_perm     = pastix_data->PTS_permtab;
    PASTIX_INT           * PTS_rev_perm = pastix_data->PTS_peritab;
    PASTIX_INT           * tmpperm      = NULL;
    PASTIX_INT           * tmpperi      = NULL;
    PASTIX_INT             gN;
    PASTIX_INT             i;
#endif

    /*
     * Check parameters
     */
    if (pastix_data == NULL) {
        errorPrint("pastix_task_symbfact: wrong pastix_data parameter");
        return PASTIX_ERR_BADPARAMETER;
    }
    iparm = pastix_data->iparm;
    /* if ( !(iparam[IPARAM_STEPS_DONE] & (API_TASK_INIT | API_TASK_ORDERING) ) { */
    /*     errorPrint("pastix_task_order: Init step should be performed before calling this function"); */
    /*     return PASTIX_ERR_BADPARAMETER; */
    /* } */

    graph    = pastix_data->csc;
    ordemesh = pastix_data->ordemesh;
    if (graph == NULL) {
        errorPrint("pastix_task_symbfact: the pastix_data->csc field has not been initialized, pastix_task_order should be called first");
        return PASTIX_ERR_BADPARAMETER;
    }
    if (ordemesh == NULL) {
        errorPrint("pastix_task_symbfact: the pastix_data->ordemesh field has not been initialized, pastix_task_order should be called first");
        return PASTIX_ERR_BADPARAMETER;
    }

    n        = graph->n;
    procnum  = pastix_data->procnum;

    print_debug(DBG_STEP, "-> pastix_task_symbfact\n");
    if (iparm[IPARM_VERBOSE] > API_VERBOSE_NO)
        pastix_print(procnum, 0, "%s", OUT_STEP_FAX);

    /* Force Load of symbmtx */
#if defined(PASTIX_SYMBOL_FORCELOAD)
    iparm[IPARM_IO_STRATEGY] = API_IO_LOAD;
#endif

    /* Allocate the symbol matrix structure */
    if (pastix_data->symbmtx == NULL) {
        MALLOC_INTERN( pastix_data->symbmtx, 1, SymbolMatrix );
    }
    else {
        errorPrint("pastix_task_symbfact: Symbol Matrix already allocated !!!");
    }

    /*
     * Symbol matrix loaded from file
     */
    if (PASTIX_MASK_ISTRUE(iparm[IPARM_IO_STRATEGY], API_IO_LOAD))
    {
        FILE *stream;
        PASTIX_FOPEN(stream, "symbname", "r" );
        symbolLoad( pastix_data->symbmtx, stream );
        fclose(stream);
    }
    /*
     * Symbol matrix computed through Fax or Kass
     */
    else
    {
        pastix_int_t  nfax;
        pastix_int_t *colptrfax;
        pastix_int_t *rowfax;

        /* Check correctness of parameters */
        if (iparm[IPARM_INCOMPLETE] == API_NO)
        {
#if defined(COMPACT_SMX)
            if (procnum == 0)
                errorPrintW("COMPACT_SMX only works with incomplete factorization, force ILU(%d) factorization.",
                            iparm[IPARM_LEVEL_OF_FILL]);
            iparm[IPARM_INCOMPLETE] = API_YES;
#endif
        }
        /* End of parameters check */

        /*
         * Fax works with centralized interface, we convert the cscd to csc if required
         */
        if (iparm[IPARM_GRAPHDIST] == API_YES)
        {
            cscd2csc_int( graph->n,
                          graph->colptr,
                          graph->rows,
                          NULL, NULL, NULL, NULL,
                          &nfax, &colptrfax, &rowfax,
                          NULL, NULL, NULL, NULL,
                          graph->loc2glob,
                          pastix_data->pastix_comm,
                          iparm[IPARM_DOF_NBR], API_YES);
        }
        else
        {
            nfax      = graph->n;
            colptrfax = graph->colptr;
            rowfax    = graph->rows;
        }

        symbolInit(pastix_data->symbmtx);

        /*
         * The amalgamate supernodes partition has been found with (PT-)Scotch,
         * we use it to generate the symbol matrix structure.
         * This works only if direct factorization will be performed.
         */
        if ( (iparm[IPARM_INCOMPLETE]    == API_NO) &&
             (iparm[IPARM_LEVEL_OF_FILL] != -1    ) &&
             (ordemesh->rangtab != NULL) )
        {
            symbolFaxGraph(pastix_data->symbmtx, /* Symbol Matrix   */
                           nfax,                 /* Number of nodes */
                           colptrfax,            /* Nodes list      */
                           rowfax,               /* Edges list      */
                           ordemesh);
        }
        /*
         * The amalgamate supernodes partition doesn't exist. (PT-)Scotch has
         * not been used, or ILU(k) factorization is performed and then, we
         * dropped the partition found by Scotch.
         * Kass is used to generate both the amalgamate supernode partition and
         * the symbol matrix stucture in this case.
         */
        else
        {
            pastix_graph_t tmpgraph;
            tmpgraph.gN     = nfax;
            tmpgraph.n      = nfax;
            tmpgraph.colptr = colptrfax;
            tmpgraph.rows   = rowfax;
            tmpgraph.loc2glob = NULL;

            kass(iparm[IPARM_INCOMPLETE],
                 iparm[IPARM_LEVEL_OF_FILL],
                 iparm[IPARM_AMALGAMATION_LEVEL],
                 pastix_data->symbmtx,
                 &tmpgraph,
                 ordemesh,
                 pastix_data->pastix_comm);
        }

        if (iparm[IPARM_GRAPHDIST] == API_YES)
        {
            memFree_null(colptrfax);
            memFree_null(rowfax);
        }

#ifdef PASTIX_DISTRIBUTED
        if (PTS_perm != NULL)
        {
            gN = n;

            MALLOC_INTERN(tmpperm, gN, PASTIX_INT);
            MALLOC_INTERN(tmpperi, gN, PASTIX_INT);
            for (i = 0; i < gN; i++)
                tmpperm[i] = ordemesh->permtab[PTS_perm[i]-1];

            memFree_null(ordemesh->permtab);
            ordemesh->permtab = tmpperm;

            for (i = 0; i < gN; i++)
                tmpperi[i] = PTS_rev_perm[ordemesh->peritab[i]]-1;
            memFree_null(ordemesh->peritab);
            ordemesh->peritab = tmpperi;

            memFree_null(PTS_perm);
            memFree_null(PTS_rev_perm);
        }
#endif /* PASTIX_DISTRIBUTED */

        memcpy(perm, ordemesh->permtab, n*sizeof(PASTIX_INT));
        memcpy(invp, ordemesh->peritab, n*sizeof(PASTIX_INT));
    } /* not API_IO_LOAD */

    /*
     * The graph is not useful anymore, we clean it
     */
    if (pastix_data->csc != NULL)
    {
        graphClean( pastix_data->csc );
        pastix_data->csc = NULL;
    }

    /*
     * Save the symbolic factorization
     */
    if (PASTIX_MASK_ISTRUE(iparm[IPARM_IO_STRATEGY], API_IO_SAVE))
    {
        FILE *stream;
        PASTIX_FOPEN(stream, "symbgen", "w");
        symbolSave(pastix_data->symbmtx, stream);
        fclose(stream);
    }

    /*
     * Dump an eps file of the symbolic factorization
     */
#if defined(PASTIX_SYMBOL_DUMP_SYMBMTX)
    if (pastix_data->procnum == 0)
    {
        FILE *stream;
        PASTIX_FOPEN(stream, "symbol.eps", "w");
        symbolDraw(pastix_data->symbmtx,
                   stream);
        fclose(stream);
    }
#endif

    /* Rebase to 0 */
    symbolBase( pastix_data->symbmtx, 0 );

    iparm[IPARM_START_TASK]++;

    return PASTIX_SUCCESS;
}
